## 📘 The Road To React

### 🐱‍🏍为什么要读呢？
> 其实刚开始工作的时候就开始用的React相关的技术栈，但也是匆匆学了一个月，自己感觉没有学的很扎实，平时做业务的时候也在想自己这么做是不是不够优雅，但迫于时间，还是将不太优雅的代码提交上去，虽然功能能够实现，但总是觉得这样不太好，所以重新来认真读一下关于React的这些书，巩固一下基础吧~

### 🐱‍🚀前言
> 这部分的笔记不会太过于详细，主要还是将整体思路都捋一遍，特别是书中组件化的这类思想自己平日里要好好落实到开发中，个人感觉刚上手的时候还是有点难度的，要加油！

### 🥇React基础
1. 首先是认识React的项目结构及业务代码的编写
2. 介绍React中的两种组件，函数组件和类组件，同时介绍了什么是JSX，将HTML和Javascript混合在一起
3. 介绍了列表在React中是如何渲染的，使用到了Map函数，Map方法不会影响原数组，会产生一个新数组
4. 第一次创建一个外部组件，使用箭头函数来定义，由此映射出大型项目时的项目结构将会是由一个个小组件叠加嵌套而成
5. React的函数定义  
   5.1 首先是传统的使用function来声明一个函数  
   5.2 使用箭头函数  
   5.3 箭头函数的使用什么情况下去掉``{}``和``return``  
6. 将事件都抽离出来单独定义
7. 将``list``变量有全局变量变为局部变量后，使用props来传递变量，也就是父组件传递到子组件的方式
8. 在将数据传递到子组件后，这里开始介绍第一个``hook``，``useState``,它返回的是一个包含两个值的数组，这里提到了数组的解构赋值。这里介绍完之后我们使用``useState``将用户在``input``框中输入的值储存起来，然后在另一个地方进行回显数据
9. 接着就可以来封装``Search``组件了，我们想要在``App``组件中访问``Search``子组件的输入，于是就介绍了子组件调用父组件的函数的方式，这里子组件不在管理``state``，而是由父组件全权接管，子组件只需要做数据的展示
10. 接下来我们想要在``Input``框中输入值后，在``list``列表中展示过滤后的值，这里介绍了``filter``函数，也是不会改变原数组，返回符合条件的新数组
11. 接下来我们发现当我们给``state``初始值的时候，``input``框中并没有显示我们的初始值，，但却显示的被过滤后的列表，这时引入了受控组件的概念,所以我们给``input``组件添加了``value``属性
12. 讲完受控组件概念后，结合之前的章节我们可以发现另一个被称为单向数据流的概念  

    > 一个 React 应用和其中的组件一开始都有一个初始 state, 可能通过 props 的方式向下传给其他组件。它会在第一次时被渲染成 UI 。一旦副作用发生，比如用户输入或者从远端 API加载数据，这个改变会在 React state 中被捕获。而一旦 state 被改变，所有受到改变的 state或者被暗中改变的 props 影响的组件将重新渲染（组件的函数会被重新调用）  

    > 每一次运行一个组件的函数会从 hooks 中使用最新值（比如当前 state ）并且不会重新执行初始化（比如初始 state）。这可能会显得有些奇怪，因为有人可能会假定 useState hooks函数会用初始值重新初始化，但其实并没有。Hooks 只会在组件第一次渲染时初始化一次，而之后 React 会在内部追踪其最新值。

13. 接下来是将一些小技巧的，关于``props``的处理。这里讲到了对象的解构  
    13.1 ``const {search, onSearch} = props``
    13.2 接着直接省略定义变量这一步，直接放到形参中进行解构  
    13.3 接着讲了嵌套解构，当值使用到一个对象下的属性时可以使用嵌套解构，直接将属性解构出去  
    13.4 我们发现这样一来父组件有大量的处理解构的代码不太好，于是介绍了展开运算符  
    13.5 使用展开运算符来对父元素进行操作，省略了大量的代码，同时这里对象属性中有一个``key``值属性只在子组件中使用，我们没必要将它也解构，所以介绍了剩余操作符，和展开运算符一样也是```...```  
    13.6 于是我们使用剩余操作符将key值留在了父组件，进行改写  
  
14. 接下来我们要新增一个功能，让``Search``组件记住最近一次搜索操作，这里我们直接在处理搜索的时候加一下``localStorage.getItem('search')``但是这样一来，我们的使用本地存储就会被看作一种副作用，这样不太好，本来处理函数应该只关心如何更新``state``，于是我们为了解决这个问题，引入了``useEffect Hook``  
    > React 的 useEffect Hook 需要两个参数：第一个参数是一个会产生副作用的函数。在我们这个例子里，副作用是指当用户输入搜索词 searchTerm 并存进浏览器的本地存储。第二个参数是所依赖的变量数组。如果任何一个依赖的变量发生变化，包含副作用的这个函数就会被调用。对于我们来说，每次 searchTerm 改变都会调用这个函数；当组件第一次渲染的时候，它也会被初始化调用。  
    > 如果 useEffect 的依赖数组是个空数组，那么这个管理副作用的函数只会被执行一次，也就是在组件第一次渲染之后。这个 hook 使我们可以有选择性地使用 React 的组件生命周期。它会在组件第一次挂载的时候被触发，也可以在它的依赖更新时被触发。

15. 接下来我们开始了解自定义``React Hook``,首先是命名规则，每个``hook``都是用``use``作为前缀，其次是把返回值都放在一个数组里，接下来完善我们的自定义``Hook``  

16. 然后开始讲``JSX``中只能有一个顶层元素，如果需要渲染多个同级的顶层元素。就必须把它们放在数组里，而且需要加上``key``值；另一种解决方式就是使用``React fragment``，也就是包一层``<></>`` , 它不会产生额外的渲染结果

17. 可复用组件中可以通过解构赋值可以添加一个默认值 

18. 接着有一个新的知识点就是可以在可复用组件之间插入元素，就像是``HTML``标签一样，并且开合标签之间还可以添加``HTML``元素的嵌套，组件中使用``props.children``接收

19. React天生是声明式的，就是我们只告诉React去渲染什么，而不是如何去渲染，而指令式就是通过指令的方式去一步步的实现指令，比如通过DOM API对元素做读写操作、实现复杂的动画效果等，那么在react中也可以实现指令式的编程，这里又介绍了另一个hook,就是``useRef``，可以访问到``HTML``元素本身有哪些属性

20. 接着介绍了React中的内联处理函数，有两种方式，一种是使用``bind``方法直接绑定参数的新函数,``<button type="button" onClick={onRemoveItem.bind(null, item)}>``,另一种更为流行的方式是包装一层箭头函数，``<button type="button" onClick={() => onRemoveItem(item)}>`` 

21. 介绍React处理异步数据， 使用``useEffect``来获取数据，并传递一个空数组，因此管理副作用的函数仅在组件首次渲染后运行


  





